# -*- coding: utf-8 -*-
"""ANN

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F3eVP5kRIyujYVa34dEbt7ZZFAh_7AGC
"""

import numpy as np

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def sigmoid_derivative(x):
    return x * (1 - x)

def initialize_weights_and_biases(X, y, num_hidden_layers, nodes_per_layer):
    input_size = X.shape[1]
    output_size = y.shape[1]
    layer_sizes = [input_size] + [nodes_per_layer] * num_hidden_layers + [output_size]
    weights = []
    biases = []
    for i in range(len(layer_sizes)-1):
        fan_in = layer_sizes[i]
        fan_out = layer_sizes[i+1]
        weight_scale = np.sqrt(2 / (fan_in + fan_out))
        weights.append(np.random.normal(size=(fan_in, fan_out)) * weight_scale)
        biases.append(np.zeros(fan_out))
    return weights, biases

def train(X, y, num_hidden_layers, nodes_per_layer):

    epochs=10000
    learning_rate=0.1

    # weights and bias initializations

    weights , biases = initialize_weights_and_biases(X, y, num_hidden_layers, nodes_per_layer)

    # train the model

    for i in range(epochs):

        # Forward propagation

        layer_outputs = [X]
        for j in range(len(weights)):
            layer_input = np.dot(layer_outputs[-1], weights[j]) + biases[j]
            layer_output = sigmoid(layer_input)
            layer_outputs.append(layer_output)
        output = layer_outputs[-1]

        # Backward propagation

        output_error = y - output
        output_delta = output_error * sigmoid_derivative(output)
        layer_deltas = [output_delta]
        for j in range(len(weights)-1, 0, -1):
            layer_error = np.dot(layer_deltas[-1], weights[j].T)
            layer_delta = layer_error * sigmoid_derivative(layer_outputs[j])
            layer_deltas.append(layer_delta)
        layer_deltas.reverse()

        # Update weights and biases
        for j in range(len(weights)):
            weights[j] += np.dot(layer_outputs[j].T, layer_deltas[j]) * learning_rate
            biases[j] += np.sum(layer_deltas[j], axis=0) * learning_rate

    # Test the model and convert output to binary
    output_binary = np.where(output > 0.5, 1, 0)
    return output_binary

# Define input and output data
X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
y = np.array([[0], [1], [1], [0]])

output = train(X, y, num_hidden_layers=2, nodes_per_layer=3)
print(output)